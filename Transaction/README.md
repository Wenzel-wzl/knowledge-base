
# ACID事务

* Atomicity 原子性

  整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

* Consistency 一致性

  一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。

* Isolation 隔离性

  隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。

* Durability 持久性

  在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

# 实现ACID

由于一项操作通常会包含许多子操作，而这些子操作可能会因为硬件的损坏或其他因素产生问题，要正确实现ACID并不容易。ACID建议数据库将所有需要更新以及修改的资料一次操作完毕，但实际上并不可行。

目前主要有两种方式实现ACID：第一种是Write ahead logging，也就是日志式的方式(现代数据库均基于这种方式)。第二种是Shadow paging。

相对于WAL（write ahead logging）技术，shadow paging技术实现起来比较简单，消除了写日志记录的开销恢复的速度也快(不需要redo和undo)。shadow paging的缺点就是事务提交时要输出多个块，这使得提交的开销很大，而且以块为单位，很难应用到允许多个事务并发执行的情况——这是它致命的缺点。

WAL 的中心思想是对数据文件 的修改（它们是表和索引的载体）必须是只能发生在这些修改已经 记录了日志之后 -- 也就是说，在日志记录冲刷到永久存储器之后． 如果我们遵循这个过程，那么我们就不需要在每次事务提交的时候 都把数据页冲刷到磁盘，因为我们知道在出现崩溃的情况下， 我们可以用日志来恢复数据库：任何尚未附加到数据页的记录 都将先从日志记录中重做（这叫向前滚动恢复，也叫做 REDO） 然后那些未提交的事务做的修改将被从数据页中删除 （这叫向后滚动恢复 - UNDO）。



# 事务的隔离级别

* A.Serializable 串行化

  一个事务在执行的过程中完全看不到其他事务对数据库的更新。
  完全服从ACID的隔离级别，确保不发生脏、虚、不可重复读。

* B.Repeatable Read 可重复读

  一个事务执行过程中可以看到其他事务已提交的新插入的数据记录，但不能看到其他事务已提交的对已有数据的更新。
  对相同字段的多次读取是一致的，除非数据被事务本身改变。可防止脏、不可重复读，但虚读仍可能发生。（MYSQL默认级别）

* C.Read Commited 读已提交数据

  一个事务执行过程中可以看到其他事务已提交的新插入的数据记录，并且能看到其他事务已提交的对已有数据的更新。
  允许在并发事务已经提交后读取。可防止脏读，但虚读和 不可重复读仍可发生（ORACLE默认级别）

* D.Read Uncommitted 读未提交数据

  一个事务执行过程中可以看到其他事务尚未提交的新插入的数据，并且能看到其他事务尚未提交的对已有数据的更新。
  允许你读取还未提交的改变了的数据。可能导致脏、虚、不可重复读（相当于没有做任何事务隔离）

事务隔离级别越高，越能保证数据完整性和一致性

对于多数应用程序，可以优先选择Read Commited隔离级别，它能避免脏读，并且有较好的并发性能，虽然会导致不可重复读、虚读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合中，应用程序可以采用悲观锁或乐观锁控制。

# 并发问题归类

* 第一类丢失更新

  撤销一个事务时，把其他事务提交的数据覆盖，导致其他事务已提交的数据丢失。两个事务同时更新相同数据，如果一个事务提交，另一个事务回滚，第一个事务会被回滚。

* 第二类丢失更新

  多个事务更新相同的数据，并完成各自的事务提交，导致最后一个事务提交会覆盖前面所有事务对数据的改变。
  
* 脏读

  第二个事务查询到第一个事务未提交的更新数据，第二个事务根据该数据执行，但第一个事务回滚，第二个事务操作脏数据。

* 虚读（幻读）

  一个事务查询到了另一个事务已经提交的新插入的数据，导致多次查询数据不同。

* 不可重复读

  一个事务查询到了另一个事务已经修改的数据，导致多次查询数据不同。
