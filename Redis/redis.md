# 基本数据结构
## RedisObject Redis对象结构
  `Redis`中每一个对象都由`RedisObject`结构表示。  
  属性：
  * unsigned `type`:4  
     对象的类型
  * unsigned `encoding`:4  
    对象的编码类型
  * void *`ptr`
    指向底层实现的数据结构的指针
  * int `lru`
    对象的过期时间，存的是时间戳，即若当前时间大于某对象的时间戳时，意味着该对象已过期。
    
  数据结构：  
  ```C
  typedef struct redisObject{
    unsigned type:4;
    unsigned encoding:4;
    void *ptr;
    int lru;
  };
  ```
  
## SDS 简单动态字符串(Simple Dynamic String)
  `SDS`长度可变，类似`C`语言中的字符串，但并不是像`C`字符串那样用空字符`\0`判断字符串是否结束，而是用`len`属性判断。  
  
  `SDS`仍然会在字符串结尾时拼上空字符`\0`，这样做的好处是，`SDS`可以复用`C`类库中的函数。  
  
  以空字符`\0`作为字符串结尾，意味着字符串中不能包含空字符。  
  因此`C`字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件等二进制数据。  
  `SDS`用`len`属性判断字符串是否结束而不是用空字符`\0`，所以不会受到仅能保存文本的限制，真正做到了，数据输入时是什么样，输出是就是什么样。  
  
  属性：  
  * int `len`  
    记录buf数组中已使用的字节数量  
    等于`SDS`所保存的字符串的长度  
  * int `free`  
    记录buf数组中为使用的字节数量  
  * char `buf`[]  
    字节数组，用于保存字符串（buf的真正长度=`len+free+1`，额外的`1byte`用于存储`\0`）    
  
  数据结构：  
  ```C
  struct sdshdr{
    int len;
    int free;
    char buf[];
  };
  ```
  
  `len`、`free`属性带来的好处：
  1. 以`O(1)`的时间复杂度获取字符串长度  
      >`C`语言获取字符串长度，需要遍历字符串直到碰见`\0`才能确定字符串的长度，因此时间复杂度为`O(n)`
  2. 杜绝缓冲区溢出  
      >字符串长度增加时，`SDS`不假设程序员已经为字符串分配足够的内存，而是依据`free`属性判断是否有足够内存，若发现内存不足，则会进行内存扩展。
  3. 减少修改字符串时带来的内存重分配次数
      >每次增减字符串内容，`C`字符串每次都需要重新分配内存，而`SDS`通过`free`属性判断是否需要重新分配内存（`free`数量足够则不进行重新分配）。  
      >`SDS`内存分配的策略：  
      >   1. 内存预分配  
      >   当`SDS`的`API`对`SDS`进行内存扩展时，不仅会为`SDS`分配必须要的内存，还会按公式分配额外的内存。  
      >   公式如下：
      >       * `SDS`修改后的长度（即`len`属性的值）小于`1MB`，则额外分配内存等于必须要的内存，即`free=len`
      >       * `SDS`修改后的长度大于等于`1MB`，则额外分配的内存等于`1MB`
      >   2. 惰性内存释放
      >   当字符串长度缩短时，`SDS`不是立即使用内存重分配来回收内存，而是用`free`记录收缩后多出来的字节数量，以应付将来的字符串长度增加。
      
## LinkedList 双端链表
## ZipList 压缩列表
## SkipList 跳跃表
## Dict 字典
## IntSet 整型集合
## HashSet 哈希集合
## ZSet 有序集合
